from typing import List, Union, Dict

from models import Model
from recipes import QAVariableContext


class Chain:
    """Base chain class.
    """
    def __init__(self, model: Model):
        """Class initialization function.

        Args:
            model (Model): Text generation model.
        """
        self.model = model
        
        self.system_message = None
        self.previous_links = None
    
    def run_chain(self) -> None:
        """Empty chain runner.

        Raises:
            NotImplementedError: This function is not implemented in this class.
        """
        raise NotImplementedError()


class IterativeImprovement(Chain):
    """Iterative improvement chain class.

    Args:
        Chain (class): Base chain class.
    """
    def __init__(self, context: bool, model: Model, num_rounds: int, chain_of_thought: bool = False):
        """Class initialization function.

        Args:
            model (Model): Text generation model.
            num_rounds (int): Number of iterative improvement rounds.
            chain_of_thought (bool, optional): Whether to use chain-of-thought prompting. Defaults to False.
        """
        super().__init__(model=model)
        
        self.num_rounds = num_rounds
        self.chain_of_thought = chain_of_thought
        self.system_message = \
            "You are a truthful and helpful oracle. You may be provided with a background text passage as context, " \
            "a question, and previous answers to this question. Please check if the most recent answer is correct. If " \
            "the most recent answer is correct, repeat the most recent answer and add \"QED.\" at the end. If the most " \
            "recent answer is incorrect, please correct the most recent answer and explain where the most recent answer went wrong."
        
        self.context = context
        if self.context:
            self.prompt_template = "{context}\n\nQuestion: {prompt}"
        else:
            self.prompt_template = "Question: {prompt}"
    
    def run_chain(self, prompts: List[str], contexts: Union[str, List[str], None] = None) -> Dict[str, List[str]]:
        """Iterative improvement chain runner.

        Args:
            prompts (List[str]): List of unformatted prompts.
            contexts (List[str]): Context string or list of context strings.

        Returns:
            Dict[str, List[str]]: Dictionary. Keys are prompts. Values are lists of text strings generated by the model.
        """
        if self.context and contexts is None:
            raise ValueError("Recipe was initialized to use context but no context was provided in the recipe call.")
        
        if self.context:
            original_prompts = [
                self.prompt_template.format(
                    context=context,
                    prompt=prompt
                )
                for context, prompt in zip(contexts, prompts)
            ]
        else:
            original_prompts = [
                self.prompt_template.format(
                    prompt=prompt
                )
                for prompt in prompts
            ]
        
        generations_dict = dict()
        for original_prompt in original_prompts:
            generations_dict[original_prompt] = []
        
        for round in range(self.num_rounds):
            if round == 0:
                if self.context:
                    self.previous_links = contexts
                else:
                    self.previous_links = None
                
                system_message = None
                prompt_template = None
                context = self.context
            else:
                self.previous_links = \
                    [f"{prompt}\n\nAnswer: {generation}" for prompt, generation in zip(prompts, generations)]
                system_message = self.system_message
                prompt_template = self.prompt_template
                context = True
            
            recipe = QAVariableContext(
                context=context,
                system_message=system_message,
                prompt_template=prompt_template,
                chain_of_thought=self.chain_of_thought
            )
            
            prompts, generations = recipe.call_recipe(
                prompts=original_prompts,
                contexts=self.previous_links,
                model=self.model
            )
            for idx, original_prompt in enumerate(original_prompts):
                generations_dict[original_prompt].append(generations[idx])
        
        return generations_dict


class Debate(Chain):
    """Debate chain class.

    Args:
        Chain (class): Base chain class.
    """
    def __init__(self, model: Model, num_rounds: int, chain_of_thought: bool = False):
        super().__init__(model=model)
        
        self.num_rounds = num_rounds
        self.chain_of_thought = chain_of_thought
        self.system_message = \
            "You are a debator who wants to come to an agreeable solution to a debate with an opposing debator. You may disagree " \
            "with your opponent if that is the best conclusion to the debate. You will be given a prompt for a debate and previous " \
            "rounds of the debate (if applicable). You {agree_type} with, or are \"{position}\" this debate prompt. Please have a " \
            "truthful and good faith debate with your opposing debator. The debate will last {num_rounds} rounds. {system_message_append}"
    
    def run_chain(self, prompts: List[str], contexts: Union[str, List[str]]) -> Dict[str, List[str]]:
        original_prompts = prompts
        
        debate_dict = {
            "for": [],
            "against": []
        }
        
        for round in range(self.num_rounds):
            if round == 0:
                for_system_message_append = \
                    "This is the first round. Please provide an opening statement for your position after being provided with the debate prompt."
                against_system_message_append = \
                    "This is the first round. Please provide a response to your opponent's opening statement."
            elif round == self.num_rounds - 1:
                for_system_message_append = \
                    "This is the final round. Please provide a final response to your opponent's previous statement."
                against_system_message_append = \
                    "This is the final round. Please provide a final response to your opponent's previous statement, along with a closing statement."
            else:
                for_system_message_append = \
                    f"There are {self.num_rounds - round} rounds remaining. Please provide a response to your opponent's previous statement."
                against_system_message_append = \
                    f"There are {self.num_rounds - round} rounds remaining. Please provide a response to your opponent's previous statement."
        
            for_system_message = self.system_message.format(
                agree_type="agree",
                position="For",
                num_rounds=self.num_rounds,
                system_message_append=for_system_message_append
            )
            against_system_message = self.system_message.format(
                agree_type="disagree",
                position="Against",
                num_rounds=self.num_rounds,
                system_message_append=against_system_message_append
            )
            
            for_recipe = QAWithContext(
                system_message=for_system_message,
                context_template=None,
                chain_of_thought=self.chain_of_thought
            )
        
